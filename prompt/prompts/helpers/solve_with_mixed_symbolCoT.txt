SYSTEM: Answer the following logic reasoning problem(s). 

Specifically, for each problem, you need to:
1. First identify the type of the problem and perform different formalizations based on the identified type:

- For deductive reasoning problems, parse the problem into first-order logic formulas using the following grammar:
1) logical conjunction of expr1 and expr2: expr1 ∧ expr2
2) logical disjunction of expr1 and expr2: expr1 ∨ expr2
3) logical exclusive disjunction of expr1 and expr2: expr1 ⊕ expr2
4) logical negation of expr1: ¬expr1
5) expr1 implies expr2: expr1 → expr2
6) expr1 if and only if expr2: expr1 ↔ expr2
7) logical universal quantification: ∀x
8) logical existential quantification: ∃x

- For Constraint Satisfaction Problems (CSPs), extract the CSP components and construct a MiniZinc model to represent the problem.
Follow these steps to convert the natural language description into a MiniZinc model:
1) Identify the key components:
   - Variables: What are the decisions that need to be made?
   - Domains: What are the possible values for each variable?
   - Constraints: What rules or conditions must be satisfied?
   - Important: when numbering, always start from left to right, old to new, cheap to expensive and so on.

2) Structure your response with clear sections:
   a. Variable and Domain Declarations:
      - Use appropriate MiniZinc types (int, bool, set, array, enum)
      - Declare domains explicitly
      - Use meaningful variable names
      - Add comments to explain nontrivial definitions

   b. Constraint Declarations:
      - Use MiniZinc's constraint syntax
      - Group related constraints with comments
      - Use forall/exists constructs where applicable
      - Do not introduce constraints that are not supported by the premise

   c. Keep in mind that MiniZinc does not allow inline comments (i.e. comments after code on the same line)

3) Use MiniZinc's built-in features:
   - Use predicate definitions for complex constraints
   - Use array comprehensions when appropriate
   - Use set operations when dealing with groups
   - Use built-in global constraints when applicable

4) Constraint usage policy for `all_different`:
   - Do not use `all_different` by default
   - Only use it when it really applies
   - If repetition is permitted or not ruled out by the premise, avoid using this constraint
   - In fact, this constraint typically is only used in cases of a many-to-many mapping with equal number of input and output instances (n-to-n mapping).
   - So for example, in the vehicle example bellow there are three vehicles for three possible chronological positions. So in this precise 3-to-3 mapping, the `all_different` constraint does need to be applied.

2. Based on the formalized problem representation, perform reasoning and provide your answer.  Return your answer in json format, using the key 'ans' to return the list of your answers to all the questions (even if there's only one question, return it as a list), and using the key 'reason' to return your reasoning process.

Below are two examples to show you how to do it:
------
(Example of deductive reasoning problems)
Statement:
Miroslav Venhoda was a Czech choral conductor who specialized in the performance of Renaissance and Baroque music. Any choral conductor is a musician. Some musicians love music. Miroslav Venhoda published a book in 1946 called Method of Studying Gregorian Chant.

Question:
Based on the above information, is the following statement true, false, or uncertain? A Czech person wrote a book in 1946.
A) True
B) False
C) Uncertain

###
output:{'ans': 'A', 'reason':'''
Predicates:
Czech(x) ::: x is a Czech person.
ChoralConductor(x) ::: x is a choral conductor.
Musician(x) ::: x is a musician.
Love(x, y) ::: x loves y.
Author(x, y) ::: x is the author of y.
Book(x) ::: x is a book.
Publish(x, y) ::: x is published in year y.
Specialize(x, y) ::: x specializes in y.
Premises:
Czech(miroslav) ∧ ChoralConductor(miroslav) ∧ Specialize(miroslav, renaissance) ∧ Specialize(miroslav, baroque) ::: Miroslav Venhoda was a Czech choral conductor who specialized in the performance of Renaissance and Baroque music.
∀x (ChoralConductor(x) → Musician(x)) ::: Any choral conductor is a musician.
∃x (Musician(x) ∧ Love(x, music)) ::: Some musicians love music.
Book(methodOfStudyingGregorianChant) ∧ Author(miroslav, methodOfStudyingGregorianChant) ∧ Publish(methodOfStudyingGregorianChant, year1946) ::: Miroslav Venhoda published a book in 1946 called Method of Studying Gregorian Chant.
Conclusions:
∃y ∃x (Czech(x) ∧ Author(x, y) ∧ Book(y) ∧ Publish(y, year1946)) ::: A Czech person wrote a book in 1946.
'''}

------
(Example of constraints satisfaction problems)
Statement:
In an antique car show, there are three vehicles with different ages:
- A tractor from 1960
- A convertible from 1955
- A minivan from 1965

The show organizer wants to arrange them in chronological order (oldest to newest) for display.

Question:
Which of the following is true?
A. The tractor is the first to be displayed.
B. The convertible is the first to be displayed.
C. The minivan is the first to be displayed.

###
Output: {'ans': 'B', 'reason':'''
include "globals.mzn";

/* VEHICLES */
enum VEHICLE = {Tractor, Convertible, Minivan};

/* MANUFACTURE YEARS */
array[VEHICLE] of int: vehicle_year = [1960, 1955, 1965];

int: num_positions = 3;
set of int: POSITION = 1..num_positions;

/* Decision variable: vehicle positions (1 = first, 3 = last) */
array[VEHICLE] of var POSITION: position;

/* Each vehicle must have a unique position */
constraint all_different(position);

/* Older vehicles appear earlier (smaller position number) */
constraint forall(v1, v2 in VEHICLE where vehicle_year[v1] < vehicle_year[v2]) (
  position[v1] < position[v2]
);

solve satisfy;

/* JSON Output */
array[int] of VEHICLE: vehicle_list = [v | v in VEHICLE];  % convert to indexed array for position control

output [
  "{\n"
] ++
[
  "  \"" ++ show(vehicle_list[i]) ++ "\": " ++ show(position[vehicle_list[i]]) ++
  (if i < length(vehicle_list) then ",\n" else "\n" endif)
  | i in 1..length(vehicle_list)
] ++
[
  "}"
];
'''}

------


USER: 
{hint}
Problem: 
{problem}

Let's think step by step.
